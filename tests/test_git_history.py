from click.testing import CliRunner
from git_history.cli import cli
from git_history.utils import RESERVED
import itertools
import json
import pytest
import subprocess
import sqlite_utils
import textwrap

git_commit = [
    "git",
    "-c",
    "user.name='Tests'",
    "-c",
    "user.email='actions@users.noreply.github.com'",
    "commit",
]


def make_repo(tmpdir):
    repo_dir = tmpdir / "repo"
    repo_dir.mkdir()
    # This one is used for the README generated by Cog:
    (repo_dir / "incidents.json").write_text(
        json.dumps(
            [
                {
                    "IncidentID": "abc123",
                    "Location": "Corner of 4th and Vermont",
                    "Type": "fire",
                },
                {
                    "IncidentID": "cde448",
                    "Location": "555 West Example Drive",
                    "Type": "medical",
                },
            ]
        ),
        "utf-8",
    )
    (repo_dir / "items.json").write_text(
        json.dumps(
            [
                {
                    "product_id": 1,
                    "name": "Gin",
                },
                {
                    "product_id": 2,
                    "name": "Tonic",
                },
            ]
        ),
        "utf-8",
    )
    (repo_dir / "items-with-reserved-columns.json").write_text(
        json.dumps(
            [
                {
                    "_id": 1,
                    "_item": "Gin",
                    "_version": "v1",
                    "_commit": "commit1",
                    "rowid": 5,
                },
                {
                    "_id": 2,
                    "_item": "Tonic",
                    "_version": "v1",
                    "_commit": "commit1",
                    "rowid": 6,
                },
            ]
        ),
        "utf-8",
    )
    (repo_dir / "items-with-banned-columns.json").write_text(
        json.dumps(
            [
                {
                    "_id_": 1,
                    "_version_": "Gin",
                }
            ]
        ),
        "utf-8",
    )
    (repo_dir / "trees.csv").write_text(
        "TreeID,name\n1,Sophia\n2,Charlie",
        "utf-8",
    )
    (repo_dir / "trees.tsv").write_text(
        "TreeID\tname\n1\tSophia\n2\tCharlie",
        "utf-8",
    )
    (repo_dir / "increment.txt").write_text("1", "utf-8")
    subprocess.call(["git", "init"], cwd=str(repo_dir))
    subprocess.call(
        [
            "git",
            "add",
            "incidents.json",
            "items.json",
            "items-with-reserved-columns.json",
            "items-with-banned-columns.json",
            "trees.csv",
            "trees.tsv",
            "increment.txt",
        ],
        cwd=str(repo_dir),
    )
    subprocess.call(git_commit + ["-m", "first"], cwd=str(repo_dir))
    subprocess.call(["git", "branch", "-m", "main"], cwd=str(repo_dir))
    (repo_dir / "items.json").write_text(
        json.dumps(
            [
                {
                    "product_id": 1,
                    "name": "Gin",
                },
                {
                    "product_id": 2,
                    "name": "Tonic 2",
                },
                {
                    "product_id": 3,
                    "name": "Rum",
                },
            ]
        ),
        "utf-8",
    )
    (repo_dir / "items-with-reserved-columns.json").write_text(
        json.dumps(
            [
                {
                    "_id": 1,
                    "_item": "Gin",
                    "_version": "v1",
                    "_commit": "commit1",
                    "rowid": 5,
                },
                {
                    "_id": 2,
                    "_item": "Tonic 2",
                    "_version": "v1",
                    "_commit": "commit1",
                    "rowid": 6,
                },
                {
                    "_id": 3,
                    "_item": "Rum",
                    "_version": "v1",
                    "_commit": "commit1",
                    "rowid": 7,
                },
            ]
        ),
        "utf-8",
    )
    subprocess.call(git_commit + ["-m", "second", "-a"], cwd=str(repo_dir))
    # Three more commits to test --skip
    for i in range(2, 4):
        (repo_dir / "increment.txt").write_text(str(i), "utf-8")
        subprocess.call(
            git_commit + ["-m", "increment {}".format(i), "-a"], cwd=str(repo_dir)
        )
    return repo_dir


@pytest.fixture
def repo(tmpdir):
    return make_repo(tmpdir)


def expected_create_view(namespace):
    return textwrap.dedent(
        """
        CREATE VIEW {namespace}_version_detail AS select
          commits.commit_at as _commit_at,
          commits.hash as _commit_hash,
          {namespace}_version.*,
          (
            select json_group_array(name) from columns
            where id in (
              select column from {namespace}_changed
              where item_version = {namespace}_version._id
            )
        ) as _changed_columns
        from {namespace}_version
          join commits on commits.id = {namespace}_version._commit
          join {namespace}_changed on {namespace}_version._id = {namespace}_changed.item_version;
    """.format(
            namespace=namespace
        )
    ).strip()


@pytest.mark.parametrize("namespace", (None, "custom"))
def test_file_without_id(repo, tmpdir, namespace):
    runner = CliRunner()
    db_path = str(tmpdir / "db.db")
    with runner.isolated_filesystem():
        options = ["file", db_path, str(repo / "items.json"), "--repo", str(repo)]
        if namespace:
            options += ["--namespace", namespace]
        result = runner.invoke(cli, options)
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    assert db.schema == (
        "CREATE TABLE [namespaces] (\n"
        "   [id] INTEGER PRIMARY KEY,\n"
        "   [name] TEXT\n"
        ");\n"
        "CREATE UNIQUE INDEX [idx_namespaces_name]\n"
        "    ON [namespaces] ([name]);\n"
        "CREATE TABLE [commits] (\n"
        "   [id] INTEGER PRIMARY KEY,\n"
        "   [namespace] INTEGER REFERENCES [namespaces]([id]),\n"
        "   [hash] TEXT,\n"
        "   [commit_at] TEXT\n"
        ");\n"
        "CREATE UNIQUE INDEX [idx_commits_namespace_hash]\n"
        "    ON [commits] ([namespace], [hash]);\n"
        "CREATE TABLE [{}] (\n".format(namespace or "item")
        + "   [product_id] INTEGER,\n"
        "   [name] TEXT\n"
        ");"
    )
    assert db["commits"].count == 2
    # Should have some duplicates
    assert [(r["product_id"], r["name"]) for r in db[namespace or "item"].rows] == [
        (1, "Gin"),
        (2, "Tonic"),
        (1, "Gin"),
        (2, "Tonic 2"),
        (3, "Rum"),
    ]


@pytest.mark.parametrize("namespace", (None, "custom"))
def test_file_with_id(repo, tmpdir, namespace):
    runner = CliRunner()
    db_path = str(tmpdir / "db.db")
    with runner.isolated_filesystem():
        result = runner.invoke(
            cli,
            [
                "file",
                db_path,
                str(repo / "items.json"),
                "--repo",
                str(repo),
                "--id",
                "product_id",
            ]
            + (["--namespace", namespace] if namespace else []),
        )
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    item_table = namespace or "item"
    version_table = "{}_version".format(item_table)
    assert db.schema == """
CREATE TABLE [namespaces] (
   [id] INTEGER PRIMARY KEY,
   [name] TEXT
);
CREATE UNIQUE INDEX [idx_namespaces_name]
    ON [namespaces] ([name]);
CREATE TABLE [commits] (
   [id] INTEGER PRIMARY KEY,
   [namespace] INTEGER REFERENCES [namespaces]([id]),
   [hash] TEXT,
   [commit_at] TEXT
);
CREATE UNIQUE INDEX [idx_commits_namespace_hash]
    ON [commits] ([namespace], [hash]);
CREATE TABLE [{namespace}] (
   [_id] INTEGER PRIMARY KEY,
   [_item_id] TEXT
, [product_id] INTEGER, [name] TEXT, [_commit] INTEGER);
CREATE UNIQUE INDEX [idx_{namespace}__item_id]
    ON [{namespace}] ([_item_id]);
CREATE TABLE [{namespace}_version] (
   [_id] INTEGER PRIMARY KEY,
   [_item] INTEGER REFERENCES [{namespace}]([_id]),
   [_version] INTEGER,
   [_commit] INTEGER REFERENCES [commits]([id]),
   [product_id] INTEGER,
   [name] TEXT,
   [_item_full_hash] TEXT
);
CREATE TABLE [columns] (
   [id] INTEGER PRIMARY KEY,
   [namespace] INTEGER REFERENCES [namespaces]([id]),
   [name] TEXT
);
CREATE UNIQUE INDEX [idx_columns_namespace_name]
    ON [columns] ([namespace], [name]);
CREATE TABLE [{namespace}_changed] (
   [item_version] INTEGER REFERENCES [{namespace}_version]([_id]),
   [column] INTEGER REFERENCES [columns]([id]),
   PRIMARY KEY ([item_version], [column])
);
{view}
""".strip().format(
        namespace=namespace or "item",
        view=expected_create_view(namespace or "item"),
    )
    assert db["commits"].count == 2
    # Should have no duplicates
    item_version = [
        r
        for r in db.query(
            "select product_id, _version, name from {}".format(version_table)
        )
    ]
    assert item_version == [
        {"product_id": 1, "_version": 1, "name": "Gin"},
        {"product_id": 2, "_version": 1, "name": "Tonic"},
        # product_id is None because it did not change here
        {"product_id": None, "_version": 2, "name": "Tonic 2"},
        {"product_id": 3, "_version": 1, "name": "Rum"},
    ]
    changed = list(
        db.query(
            """
        select
          {namespace}.product_id,
          {namespace}_version._version as version,
          columns.name as column_name
        from {namespace}_changed
          join columns on {namespace}_changed.column = columns.id
          join {namespace}_version on {namespace}_changed.item_version = {namespace}_version._id
          join {namespace} on {namespace}._id = {namespace}_version._item
        order by {namespace}.product_id, {namespace}_version._version, columns.name
    """.format(
                namespace=namespace or "item"
            )
        )
    )
    assert changed == [
        {"product_id": 1, "version": 1, "column_name": "name"},
        {"product_id": 1, "version": 1, "column_name": "product_id"},
        {"product_id": 2, "version": 1, "column_name": "name"},
        {"product_id": 2, "version": 1, "column_name": "product_id"},
        {"product_id": 2, "version": 2, "column_name": "name"},
        {"product_id": 3, "version": 1, "column_name": "name"},
        {"product_id": 3, "version": 1, "column_name": "product_id"},
    ]
    # Test the view
    view_rows = list(
        db.query(
            "select _version, product_id, name, _changed_columns from {}_version_detail".format(
                namespace or "item"
            )
        )
    )
    # Sort order of _changed_columns JSON is undefined, so fix that
    for row in view_rows:
        row["_changed_columns"] = list(sorted(json.loads(row["_changed_columns"])))
    assert view_rows == [
        {
            "_version": 1,
            "product_id": 1,
            "name": "Gin",
            "_changed_columns": ["name", "product_id"],
        },
        {
            "_version": 1,
            "product_id": 1,
            "name": "Gin",
            "_changed_columns": ["name", "product_id"],
        },
        {
            "_version": 1,
            "product_id": 2,
            "name": "Tonic",
            "_changed_columns": ["name", "product_id"],
        },
        {
            "_version": 1,
            "product_id": 2,
            "name": "Tonic",
            "_changed_columns": ["name", "product_id"],
        },
        {
            "_version": 2,
            "product_id": None,
            "name": "Tonic 2",
            "_changed_columns": ["name"],
        },
        {
            "_version": 1,
            "product_id": 3,
            "name": "Rum",
            "_changed_columns": ["name", "product_id"],
        },
        {
            "_version": 1,
            "product_id": 3,
            "name": "Rum",
            "_changed_columns": ["name", "product_id"],
        },
    ]


def test_file_with_id_resume(repo, tmpdir):
    runner = CliRunner()
    db_path = str(tmpdir / "db.db")
    result = runner.invoke(
        cli,
        [
            "file",
            db_path,
            str(repo / "items.json"),
            "--repo",
            str(repo),
            "--id",
            "product_id",
        ],
    )
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    item_version = [
        r for r in db.query("select product_id, _version, name from item_version")
    ]
    assert item_version == [
        {"product_id": 1, "_version": 1, "name": "Gin"},
        {"product_id": 2, "_version": 1, "name": "Tonic"},
        {"product_id": None, "_version": 2, "name": "Tonic 2"},
        {"product_id": 3, "_version": 1, "name": "Rum"},
    ]
    # Now we edit, commit and try again
    (repo / "items.json").write_text(
        json.dumps(
            [
                {"product_id": 1, "name": "Gin"},
                {"product_id": 2, "name": "Tonic 2"},
                # This line has changed from "Rum" to "Rum Pony":
                {"product_id": 3, "name": "Rum Pony"},
            ]
        ),
        "utf-8",
    )
    subprocess.call(git_commit + ["-a", "-m", "another"], cwd=str(repo))
    result2 = runner.invoke(
        cli,
        [
            "file",
            db_path,
            str(repo / "items.json"),
            "--repo",
            str(repo),
            "--id",
            "product_id",
        ],
        catch_exceptions=False,
    )
    assert result2.exit_code == 0
    item_version2 = [
        r
        for r in db.query(
            "select _item, product_id, _version, name from item_version order by _item, _version"
        )
    ]
    assert item_version2 == [
        {"_item": 1, "product_id": 1, "_version": 1, "name": "Gin"},
        {"_item": 2, "product_id": 2, "_version": 1, "name": "Tonic"},
        {"_item": 2, "product_id": None, "_version": 2, "name": "Tonic 2"},
        {"_item": 3, "product_id": 3, "_version": 1, "name": "Rum"},
        {"_item": 3, "product_id": None, "_version": 2, "name": "Rum Pony"},
    ]


@pytest.mark.parametrize("namespace", (None, "custom"))
def test_file_with_id_full_versions(repo, tmpdir, namespace):
    runner = CliRunner()
    db_path = str(tmpdir / "db.db")
    with runner.isolated_filesystem():
        result = runner.invoke(
            cli,
            [
                "file",
                db_path,
                str(repo / "items.json"),
                "--repo",
                str(repo),
                "--id",
                "product_id",
                "--full-versions",
            ]
            + (["--namespace", namespace] if namespace else []),
        )
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    item_table = namespace or "item"
    version_table = "{}_version".format(item_table)
    assert db.schema == (
        "CREATE TABLE [namespaces] (\n"
        "   [id] INTEGER PRIMARY KEY,\n"
        "   [name] TEXT\n"
        ");\n"
        "CREATE UNIQUE INDEX [idx_namespaces_name]\n"
        "    ON [namespaces] ([name]);\n"
        "CREATE TABLE [commits] (\n"
        "   [id] INTEGER PRIMARY KEY,\n"
        "   [namespace] INTEGER REFERENCES [namespaces]([id]),\n"
        "   [hash] TEXT,\n"
        "   [commit_at] TEXT\n"
        ");\n"
        "CREATE UNIQUE INDEX [idx_commits_namespace_hash]\n"
        "    ON [commits] ([namespace], [hash]);\n"
        "CREATE TABLE [{}] (\n".format(item_table) + "   [_id] INTEGER PRIMARY KEY,\n"
        "   [_item_id] TEXT\n"
        ", [product_id] INTEGER, [name] TEXT, [_commit] INTEGER);\n"
        "CREATE UNIQUE INDEX [idx_{}__item_id]\n".format(item_table)
        + "    ON [{}] ([_item_id]);\n".format(item_table)
        + "CREATE TABLE [{}] (\n".format(version_table)
        + "   [_id] INTEGER PRIMARY KEY,\n"
        "   [_item] INTEGER REFERENCES [{}]([_id]),\n".format(item_table)
        + "   [_version] INTEGER,\n"
        "   [_commit] INTEGER REFERENCES [commits]([id]),\n"
        "   [product_id] INTEGER,\n"
        "   [name] TEXT\n"
        ");\n" + expected_create_view(namespace or "item")
    )
    assert db["commits"].count == 2
    # Should have no duplicates
    item_version = [
        r
        for r in db.query(
            "select product_id, _version, name from {}".format(version_table)
        )
    ]
    assert item_version == [
        {"product_id": 1, "_version": 1, "name": "Gin"},
        {"product_id": 2, "_version": 1, "name": "Tonic"},
        {"product_id": 2, "_version": 2, "name": "Tonic 2"},
        {"product_id": 3, "_version": 1, "name": "Rum"},
    ]


def test_file_with_reserved_columns(repo, tmpdir):
    runner = CliRunner()
    db_path = str(tmpdir / "reserved.db")
    with runner.isolated_filesystem():
        result = runner.invoke(
            cli,
            [
                "file",
                db_path,
                str(repo / "items-with-reserved-columns.json"),
                "--repo",
                str(repo),
                "--id",
                "_id",
                "--full-versions",
            ],
            catch_exceptions=False,
        )
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    expected_schema = (
        textwrap.dedent(
            """
        CREATE TABLE [namespaces] (
           [id] INTEGER PRIMARY KEY,
           [name] TEXT
        );
        CREATE UNIQUE INDEX [idx_namespaces_name]
            ON [namespaces] ([name]);
        CREATE TABLE [commits] (
           [id] INTEGER PRIMARY KEY,
           [namespace] INTEGER REFERENCES [namespaces]([id]),
           [hash] TEXT,
           [commit_at] TEXT
        );
        CREATE UNIQUE INDEX [idx_commits_namespace_hash]
            ON [commits] ([namespace], [hash]);
        CREATE TABLE [item] (
           [_id] INTEGER PRIMARY KEY,
           [_item_id] TEXT
        , [_id_] INTEGER, [_item_] TEXT, [_version_] TEXT, [_commit_] TEXT, [rowid_] INTEGER, [_commit] INTEGER);
        CREATE UNIQUE INDEX [idx_item__item_id]
            ON [item] ([_item_id]);
        CREATE TABLE [item_version] (
           [_id] INTEGER PRIMARY KEY,
           [_item] INTEGER REFERENCES [item]([_id]),
           [_version] INTEGER,
           [_commit] INTEGER REFERENCES [commits]([id]),
           [_id_] INTEGER,
           [_item_] TEXT,
           [_version_] TEXT,
           [_commit_] TEXT,
           [rowid_] INTEGER
        );"""
        )
        + "\n"
        + expected_create_view("item")
    ).strip()

    assert db.schema == expected_schema
    item_version = [
        r
        for r in db.query(
            "select _id_, _item_, _version_, _commit_, rowid_ from item_version"
        )
    ]
    assert item_version == [
        {
            "_id_": 1,
            "_item_": "Gin",
            "_version_": "v1",
            "_commit_": "commit1",
            "rowid_": 5,
        },
        {
            "_id_": 2,
            "_item_": "Tonic",
            "_version_": "v1",
            "_commit_": "commit1",
            "rowid_": 6,
        },
        {
            "_id_": 2,
            "_item_": "Tonic 2",
            "_version_": "v1",
            "_commit_": "commit1",
            "rowid_": 6,
        },
        {
            "_id_": 3,
            "_item_": "Rum",
            "_version_": "v1",
            "_commit_": "commit1",
            "rowid_": 7,
        },
    ]


@pytest.mark.parametrize("file", ("trees.csv", "trees.tsv"))
def test_csv_tsv(repo, tmpdir, file):
    runner = CliRunner()
    db_path = str(tmpdir / "db.db")
    with runner.isolated_filesystem():
        result = runner.invoke(
            cli,
            [
                "file",
                db_path,
                str(repo / file),
                "--repo",
                str(repo),
                "--id",
                "TreeID",
                "--csv",
                "--full-versions",
            ],
            catch_exceptions=False,
        )
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    assert (
        db.schema
        == textwrap.dedent(
            """
        CREATE TABLE [namespaces] (
           [id] INTEGER PRIMARY KEY,
           [name] TEXT
        );
        CREATE UNIQUE INDEX [idx_namespaces_name]
            ON [namespaces] ([name]);
        CREATE TABLE [commits] (
           [id] INTEGER PRIMARY KEY,
           [namespace] INTEGER REFERENCES [namespaces]([id]),
           [hash] TEXT,
           [commit_at] TEXT
        );
        CREATE UNIQUE INDEX [idx_commits_namespace_hash]
            ON [commits] ([namespace], [hash]);
        CREATE TABLE [item] (
           [_id] INTEGER PRIMARY KEY,
           [_item_id] TEXT
        , [TreeID] TEXT, [name] TEXT, [_commit] INTEGER);
        CREATE UNIQUE INDEX [idx_item__item_id]
            ON [item] ([_item_id]);
        CREATE TABLE [item_version] (
           [_id] INTEGER PRIMARY KEY,
           [_item] INTEGER REFERENCES [item]([_id]),
           [_version] INTEGER,
           [_commit] INTEGER REFERENCES [commits]([id]),
           [TreeID] TEXT,
           [name] TEXT
        );"""
        ).strip()
        + "\n"
        + expected_create_view("item")
    )


@pytest.mark.parametrize(
    "dialect,expected_schema",
    (
        ("excel", "CREATE TABLE [item] (\n   [TreeID] TEXT,\n   [name] TEXT\n)"),
        ("excel-tab", "CREATE TABLE [item] (\n   [TreeID,name] TEXT\n)"),
    ),
)
def test_csv_dialect(repo, tmpdir, dialect, expected_schema):
    runner = CliRunner()
    db_path = str(tmpdir / "db.db")
    with runner.isolated_filesystem():
        result = runner.invoke(
            cli,
            [
                "file",
                db_path,
                str(repo / "trees.csv"),
                "--repo",
                str(repo),
                "--dialect",
                dialect,
            ],
            catch_exceptions=False,
        )
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    assert db["item"].schema == expected_schema


@pytest.mark.parametrize(
    "convert,expected_rows",
    (
        (
            "json.loads(content.upper())",
            [
                {"PRODUCT_ID": 1, "NAME": "GIN"},
                {"PRODUCT_ID": 2, "NAME": "TONIC"},
                {"PRODUCT_ID": 1, "NAME": "GIN"},
                {"PRODUCT_ID": 2, "NAME": "TONIC 2"},
                {"PRODUCT_ID": 3, "NAME": "RUM"},
            ],
        ),
        # Generator
        (
            (
                "data = json.loads(content)\n"
                "for item in data:\n"
                '    yield {"just_name": item["name"]}'
            ),
            [
                {"just_name": "Gin"},
                {"just_name": "Tonic"},
                {"just_name": "Gin"},
                {"just_name": "Tonic 2"},
                {"just_name": "Rum"},
            ],
        ),
    ),
)
def test_convert(repo, tmpdir, convert, expected_rows):
    runner = CliRunner()
    db_path = str(tmpdir / "db.db")
    with runner.isolated_filesystem():
        result = runner.invoke(
            cli,
            [
                "file",
                db_path,
                str(repo / "items.json"),
                "--repo",
                str(repo),
                "--convert",
                convert,
            ],
            catch_exceptions=False,
        )
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    rows = [{k: v for k, v in r.items() if k != "_commit"} for r in db["item"].rows]
    assert rows == expected_rows


@pytest.mark.parametrize(
    "options,expected_texts",
    (
        ([], ["1", "2", "3"]),
        (["--skip", 0], ["2", "3"]),
        (["--skip", 0, "--skip", 2], ["3"]),
        (["--start-at", 2], ["2", "3"]),
        (["--start-after", 2], ["3"]),
        (["--start-at", 3], ["3"]),
        (["--start-after", 3], []),
    ),
)
def test_skip_options(repo, tmpdir, options, expected_texts):
    runner = CliRunner()
    commits = list(
        reversed(
            subprocess.check_output(["git", "log", "--pretty=format:%H"], cwd=str(repo))
            .decode("utf-8")
            .split("\n")
        )
    )
    assert len(commits) == 4
    # Rewrite options to replace integers with the corresponding commit hash
    options = [commits[item] if isinstance(item, int) else item for item in options]
    db_path = str(tmpdir / "db.db")
    result = runner.invoke(
        cli,
        [
            "file",
            db_path,
            str(repo / "increment.txt"),
            "--repo",
            str(repo),
            "--convert",
            '[{"id": 1, "text": content.decode("utf-8")}]',
            "--id",
            "id",
        ]
        + options,
        catch_exceptions=False,
    )
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    actual_text = [r["text"] for r in db["item_version"].rows]
    assert actual_text == expected_texts


def test_reserved_columns_are_reserved(tmpdir, repo):
    runner = CliRunner()
    db_path = str(tmpdir / "db.db")
    runner.invoke(
        cli,
        [
            "file",
            db_path,
            str(repo / "items.json"),
            "--repo",
            str(repo),
            "--id",
            "product_id",
        ],
    )
    # Find all columns with _ prefixes and no suffix
    db = sqlite_utils.Database(db_path)
    with_prefix = {"rowid"}
    for table in itertools.chain(db.tables, db.views):
        for column in table.columns_dict:
            if column.startswith("_") and not column.endswith("_"):
                with_prefix.add(column)
    assert with_prefix == set(RESERVED)


@pytest.mark.parametrize("use_wal", (True, False))
def test_wal(repo, tmpdir, use_wal):
    runner = CliRunner()
    db_path = str(tmpdir / "db.db")
    options = [
        "file",
        db_path,
        str(repo / "items.json"),
        "--repo",
        str(repo),
    ]
    if use_wal:
        options.append("--wal")
    result = runner.invoke(
        cli,
        options,
        catch_exceptions=False,
    )
    assert result.exit_code == 0
    db = sqlite_utils.Database(db_path)
    expected_journal_mode = "wal" if use_wal else "delete"
    assert db.journal_mode == expected_journal_mode
